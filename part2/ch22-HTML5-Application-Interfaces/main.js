// ! Геолокация
navigator.geolocation.getCurrentPosition(function(pos) {
    var latitude = pos.coords.latitude;
    var longitude = pos.coords.longitude;
    alert("Ваши координаты: " + latitude + ", " + longitude);
});

// Возвращает вновь созданный элемент <img>, настроенный (в случае успешного 
// определения местонахождения) на отображение карты для текущего  местонахождения.
// Обратите внимание, что вызывающая программа сама должна  вставить возвращаемый
// элемент в документ, чтобы отобразить его. Возбуждает исключение, если возможность
// определения местонахождения не поддерживается броузером.
function getmap() {
    // Проверить поддержку объекта geolocation
    if (!navigator.geolocation) throw "Определение местонахождения не поддерживается";
    // Создать новый элемент <img>, отправить запрос определения местонахождения,
    // чтобы в img отобразить карту местонахождения и вернуть изображение.
    var image = document.createElement("img");
    navigator.geolocation.getCurrentPosition(setMapURL);
    return image;
    // Эта функция будет вызвана после того, как вызывающая программа получит объект
    // изображения, в случае успешного выполнения запроса определения местонахождения.
    function setMapURL(pos) {
        // Получить информацию о местонахождении из объекта аргумента
        var latitude = pos.coords.latitude; // Градусы к северу от экватора
        var longitude = pos.coords.longitude; // Градусы к востоку от Гринвича
        var accuracy = pos.coords.accuracy; // Метры 
        // Сконструировать URL для получения статического изображения  карты
        // от службы Google Map для этого местонахождения
        var url = "http://maps.google.com/maps/api/staticmap" + "?center=" + latitude + "," + longitude + "&size=640x640&sensor=true";
        // Установить масштаб карты, используя грубое приближение
        var zoomlevel=20; // Для начала установить самый крупный  масштаб
        if (accuracy > 80) // Уменьшить масштаб для низкой точности
        zoomlevel -= Math.round(Math.log(accuracy/50)/Math.LN2);
        url += "&zoom=" + zoomlevel; // Добавить масштаб в URL
        // Отобразить карту в объекте изображения. Спасибо, Google!
        image.src = url;
    }
}

// Асинхронно определяет местонахождение и отображает его в указанном элементе. 
function whereami(elt) {
    // Этот объект передается методу getCurrentPosition() в 3 аргументе
    var options = {
        // Чтобы получить координаты с высокой очностью (например, с устройства GPS),
        // присвойте этому свойству значение true. Отметьте, однако, что это может
        // увеличить расход энергии в аккумуляторах.
        enableHighAccuracy: false, // Приблизительно: по умолчанию 
        // Определите свое значение, если допустимо брать координаты из кэша.
        // По умолчанию имеет начение 0, что обеспечивает получение самой свежей информации. 
        maximumAge: 300000, // Пригодна информация, полученная в течение последних 5 минут 
        // Предельное время ожидания выполнения запроса.
        // По умолчанию имеет значение Infinity, что соответствует бесконечному 
        // времени ожидания выполнения запроса вызовом метода getCurrentPosition()
        timeout: 15000 // Ждать не более 15 секунд
    };
    if (navigator.geolocation) // Запросить координаты, если возможно
        navigator.geolocation.getCurrentPosition(success, error, options);
    else
        elt.innerHTML = "Возможность определения местонахождения " + "не поддерживается этим броузером";
    // Эта функция будет вызвана в случае неудачного выполнения запроса
    function error(e) {
        // Объект ошибки содержит числовой код и текстовое сообщение. Коды: 
        // 1: пользователь не дал разрешения на определение местонахождения
        // 2: броузер не смог определить местонахождение
        // 3: истекло предельное время ожидания
        elt.innerHTML = "Ошибка определения местонахождения " + e.code + ": " + e.message; 
    }
    // Эта функция будет вызвана в случае успешного выполнения запроса
    function success(pos) {
        // Эти поля возвращаются всегда. Обратите внимание, что поле timestamp
        // принадлежит внешнему объекту pos, а не вложенному coords.
        var msg = "At " + new Date(pos.timestamp).toLocaleString() + " вы находились в " + pos.coords.accuracy + " метрах от точки " + pos.coords.latitude +  " северной широты " + pos.coords.longitude + " восточной долготы."; 
        // Если устройство возвращает высоту над уровнем моря, добавить эту информацию.
        if (pos.coords.altitude) {
            msg += " Вы находитесь на высоте " + pos.coords.altitude + " ± " + pos.coords.altitudeAccuracy + " метров над уровнем моря.";
        }
        // Если устройство возвращает направление и скорость движения,
        // добавить и эту информацию.
        if (pos.coords.speed) {
            msg += " Вы перемещаетесь со скоростью " + pos.coords.speed + "м/сек в направлении " + pos.coords.heading + ".";
        }
        elt.innerHTML = msg; // Отобразить информацию о местонахождении
    }
}

// ! Фоновые потоки выполнения 
var loader = new Worker("utils/loader.js"); // создать новый поток
loader.postMessage("file.txt"); 
worker.onmessage = function(e) {
    var message = e.data; // Извлечь сообщение 
    console.log("Содержимое: " + message); // Выполнить некоторые действия
}
worker.onerror = function(e) {
    // Вывести текст ошибки, включая имя файла фонового потока и номер строки
    console.log("Ошибка в " + e.filename + ":" + e.lineno + ": " + e.message);
}
// Перед началом работы загрузить  необходимые классы и утилиты
importScripts("collections/Set.js", "collections/Map.js", "utils/base64.js");

// Асинхронная замена изображения его смазанной  версией.
// Используется так: <img src="testimage.jpg" onclick="smear(this)"/>
function smear(img) {
    // Создать неотображаемый элемент <canvas> того же размера,  что и изображение
    var canvas = document.createElement("canvas");
    canvas.width = img.width;
    canvas.height = img.height;
    // Скопировать изображение в холст и извлечь его пикселы 
    var context = canvas.getContext("2d");
    context.drawImage(img, 0, 0);
    var pixels = context.getImageData(0,0,img.width,img.height)
    // Отправить пикселы фоновому потоку выполнения 
    var worker = new Worker("SmearWorker.js"); // Создать фоновый поток
    worker.postMessage(pixels); // Скопировать и отдать пикселы
    // Зарегистрировать обработчик для получения ответа от фонового потока
    worker.onmessage = function(e) {
        var smeared_pixels = e.data; // Пикселы, полученные от потока
        context.putImageData(smeared_pixels, 0, 0); // Скопировать в холст
        img.src = canvas.toDataURL(); // А затем в изображение
        worker.terminate(); // Остановить поток
        canvas.width = canvas.height = 0; // Освободить память
    }
}

// Получает объект ImageData от основного потока выполнения, обрабатывает его
// и отправляет обратно
onmessage = function(e) { postMessage(smear(e.data)); }
// Смазывает пикселы в ImageData вправо, воспроизводя эффект  быстрого движения.
// При обработке больших изображений этой функции приходится выполнять огромный объем
// вычислений, что может вызвать эффект подвисания пользовательского интерфейса,
// если использовать ее в основном потоке выполнения.
function smear(pixels) {
    var data = pixels.data, width = pixels.width, height = pixels.height;
    var n = 10, m = n-1; // Чем больше n, тем сильнее эффект смазывания
    for(var row = 0; row < height; row++) { // Для каждой строки
        var i = row*width*4 + 4; // Индекс 2-го пиксела
        for(var col = 1; col < width; col++, i += 4) { // Для каждого столбца
            data[i] = (data[i] + data[i-4]*m)/n; // Красная составляющая
            data[i+1] = (data[i+1] + data[i-3]*m)/n; // Зеленая
            data[i+2] = (data[i+2] + data[i-2]*m)/n; // Синяя
            data[i+3] = (data[i+3] + data[i-1]*m)/n; // Альфа-составляющая
        }
    }
    return pixels;
}

// Этот файл будет загружен вызовом конструктора Worker(), поэтому он будет выполняться
// в независимом потоке выполнения и может безопасно  использовать синхронный прикладной
// интерфейс объекта XMLHttpRequest. В качестве сообщения фоновому потоку должен
// передаваться массив URL-адресов.  Поток синхронно извлечет содержимое
// из указанных адресов и вернет его в виде массива строк.
onmessage = function(e) {
    var urls = e.data; // Входные данные: URL-адреса извлекаемого содержимого 
    var contents = []; // Выходные данные: содержимое указанных URL-адресов
    for(var i = 0; i < urls.length; i++) {
        var url = urls[i]; // Для каждого URL-адреса
        var xhr = new XMLHttpRequest(); // Создать HTTP-запрос
        xhr.open("GET", url, false); // false обеспечит синхронное выполн.
        xhr.send(); // Блокируется до выполнения запроса
        if (xhr.status !== 200) // Возбудить исключение при неудаче
            throw Error(xhr.status + " " + xhr.statusText + ": " + url);
        contents.push(xhr.responseText); // Иначе сохранить содержимое
    }
    // Отослать массив содержимого URL-адресов  обратно основному потоку
    postMessage(contents);
}

// ! Типизированные массивы и буферы
var bytes = new Uint8Array(1024); // Один килобайт байтов
for(var i = 0; i < bytes.length; i++) // Для каждого элемента массива
bytes[i] = i & 0xFF; // Записать 8 младших бит индекса
var copy = new Uint8Array(bytes); // Создать копию массива
var ints = new Int32Array([0,1,2,3]); // Типизированный массив с 4 целыми

// Возвращает наибольшее целое  простое число меньше n.
// Использует алгоритм "Решето Эратосфена" 
function sieve(n) {
    var a = new Int8Array(n+1); // в a[x] записывается 1, если x - составное число
    var max = Math.floor(Math.sqrt(n)); // Множитель не может быть выше этого значения
    var p = 2; // 2 - первое простое число
    while(p <= max) { // Для простых чисел меньше max
        for(var i = 2*p; i <= n; i += p) // Пометить числа, кратные p,
            a[i] = 1; // как составные
        while(a[++p]) /* пустое тело */; // Следующий непомеченный индекс -
    } // простое число
    while(a[n]) n--; // Цикл в обр. напр., чтобы отыскать последнее простое
    return n; // И вернуть его
}

var matrix = new Float64Array(9); // Матрица 3x3
var Point3d = new Int16Array(3); // Точка в 3-мерном пространстве
var rgba = new Uint8Array(4); // 4-байтовое значение RGBA пиксела
var sudoku = new Uint8Array(81); // Доска 9x9 для игры в судоку

var bytes = new Uint8Array(1024) // Буфер размером 1Kбайт
var pattern = new Uint8Array([0,1,2,3]); // Массив из 4 байтов 
bytes.set(pattern); // Скопировать их в начало другого массива байтов
bytes.set(pattern, 4); // Скопировать их же в другое место массива
bytes.set([0,1,2,3], 8); // Просто скопировать значения из обычного массива

var ints = new Int16Array([0,1,2,3,4,5,6,7,8,9]); // 10 коротких целых
var last3 = ints.subarray(ints.length-3, ints.length); // Последние 3 из них
last3[0] // => 7: то же самое, что и ints[7]

ints[9] = -1; // Изменить значение в оригинальном массиве и...
last3[2] // => -1: изменения коснулись фрагмента массива

last3.buffer // => вернет объект ArrayBuffer
last3.buffer == ints.buffer // => true: оба - представления одного буфера
last3.byteOffset // => 14: это представление начинается с 14-го байта в буфере
last3.byteLength // => 6: размер представления 6 байт (3 16-битных целых)
last3.byteLength // => 6: размер представления 6 байт
last3.buffer.byteLength // => 20: но буфер имеет размер 20 байт

var bytes = new Uint8Array(8); // Разместить 8 байтов
bytes[0] = 1; // Записать в первый байт значение 1
bytes.buffer[0] // => undefined: буфер не имеет индекса 0
bytes.buffer[1] = 255; // Попробовать некорректно записать значение в байт буфера
bytes.buffer[1] // => 255: это обычное JavaScript-свойство
bytes[1] // => 0: строка выше не изменила байт

var buf = new ArrayBuffer(1024*1024); // Один Мбайт
var asbytes = new Uint8Array(buf); // Представление в виде байтов
var asints = new Int32Array(buf); // В виде 32-битных целых со знаком
var lastK = new Uint8Array(buf,1023*1024); // Последний Кбайт в виде байтов
var ints2 = new Int32Array(buf, 1024, 256); // 2-й Кбайт в виде 256 целых чисел

// Если целое число 0x00000001 располагается в памяти в виде
// последовательности байтов 01 00 00 00, следовательно, сценарий выполняется
// на платформе с обратным порядком следования байтов. На платформе с прямым
// порядком следования байтов мы получим байты 00 00 00 01.
var little_endian = new Int8Array(new Int32Array([1]).buffer)[0] === 1;

var data; // Предположим, что данные в ArrayBuffer получены из сети
var view = DataView(data); // Создать представление буфера
var int = view.getInt32(0); // 32-битное целое со знаком с прямым порядком
// следования байтов, начиная с 0-го байта
int = view.getInt32(4,false); // Следующее 32-битное целое, также с прямым 
// порядком следования байтов
int = view.getInt32(8,true) // Следующие 4 байта как целое со знаком
// и с обратным  порядком следования байтов
view.setInt32(8,int,false); // Записать его обратно, в формате с прямым
// порядком следования байтов

// ! Двоичные объекты

// var blob = ... // Как получить двоичный объект, будет показано ниже
blob.size // Размер двоичного объекта в байтах
blob.type // MIME-тип двоичного объекта или "", если неизвестен
var subblob = blob.slice(0,1024, "text/plain"); // Первый килобайт – как текст
var last = blob.slice(blob.size-1024, 1024); // Последний килобайт - как нетипизированные данные

// Загрузка двоичных объектов
// Запрашивает методом GET содержимое URL в виде  двоичного объекта и передает его
// указанной функции обратного вызова. Этот программный код не тестировался: на тот
// момент, когда он был написан, броузеры еще не поддерживали этот прикладной интерфейс.
function getBlob(url, callback) {
    var xhr = new XMLHttpRequest(); // Создать новый объект XHR
    xhr.open("GET", url); // Указать URL-адрес
    xhr.responseType = "blob" // Желательно получить двоичный объект
    xhr.onload = function() { // onload проще, чем onreadystatechange
        callback(xhr.response); // Передать ответ функции обратного вызова
    } // Отметьте: .response, а не .responseText
    xhr.send(null); // Послать запрос
}

// Создать новый объект BlobBuilder 
var bb = new BlobBuilder();
// Добавить в двоичный объект строку и отметить ее конец символом NUL
bb.append("Данный двоичный объект содержит этот текст и 10 " + "32-битных целых чисел с прямым порядком следования байтов.");
bb.append("\0"); // Добавить символ NUL, чтобы отметить конец строки
// Сохранить некоторые данные в объекте ArrayBuffer
var ab = new ArrayBuffer(4*10);
var dv = new DataView(ab);
for(var i = 0; i < 10; i++) dv.setInt32(i*4,i);
// Добавить ArrayBuffer в двоичный объект
bb.append(ab);
// Теперь извлечь полученный двоичный объект, указав искусственный MIME-тип
var blob = bb.getBlob("x-optional/mime-type-here");

