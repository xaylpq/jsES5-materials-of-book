// Использование пустой инструкции
// Инициализировать массив a
for(i=0; i <a.length; a[i++]=0) /* Пустое тело цикла */ ;

var x = 2, // Множество переменных...
    f = function(x) { return x*x }, // каждая определяется
    y = f(x);

function hypotenuse(x, y) {
    return Math.sqrt(x*x + y*y);
}

function factorial(n) { // Рекурсивная функция
    if (n <= 1) return 1;
        return n * factorial(n - 1);
}

if (username == null) // Если переменная username равна null или undefined,
username = "John Doe"; // определить ее

// Если переменная username равна null, undefined, 0, "" или NaN,
// присвоить ей новое значение. 
if (!username) username = "John Doe";

switch(n) {
    case 1: // Выполняется, если n === 1
        // Выполнить блок 1.
        break; // Здесь остановиться
    case 2: // Выполняется, если n === 2
        // Выполнить блок 2.
        break; // Здесь остановиться
    case 3: // Выполняется, если n === 3
        // Выполнить блок 3.
        break; // Здесь остановиться
    default: // Если все остальное не подходит...
        // Выполнить блок 4.
        break; // Здесь остановиться
}

function convert(x) {
    switch(typeof x) {
        case 'number': // Преобразовать число в шестнадцатеричное целое
            return x.toString(16);
        case 'string': // Вернуть строку, заключенную в кавычки
            return '"' + x + '"';
        default: // Любой другой тип преобразуется обычным способом
            return x.toString()
    }
}

function printArray(a) {
    var len = a.length, i = 0;
    if (len == 0)
        console.log("Пустой массив");
    else {
        do {
            console.log(a[i]);
        } while (++i < len);
    }
}

for(инициализация; проверка; инкремент)
    инструкция

инициализация;
while(проверка)
{
    инструкция
    инкремент;
}

for(var count = 0; count < 10; count++)
    console.log(count);

function tail(o) {                              // Возвращает последний элемент в списке o
    for(; o.next; o = o.next) /* пустое */ ;    // Выполнять обход, пока o.next
    return o;                                   // является истинным значением
}

for (переменная in объект)
    инструкция

for(var i = 0; i < a.length; i++) // Присваивать индексы в массиве переменной i
    console.log(a[i]); // Вывести значение каждого элемента массива

var o = {x:1, y:2, z:3};
var a = []; var i = 0;
for(a[i++] in o) /* пустое тело цикла */ ;

// Пример использования инструкции break;
for(var i = 0; i < a.length; i++) {
    if (a[i] == target) break;
}

var matrix = getData(); // Получить 2-мерный массив чисел откуда-нибудь
// Найти сумму всех чисел в матрице.
var sum = 0, success = false;
// Пометить инструкцию, выполнение которой требуется прервать в случае ошибки
compute_sum: if (matrix) {
    for(var x = 0; x < matrix.length; x++) {
        var row = matrix[x];
        if (!row) break compute_sum;
        for(var y = 0; y < row.length; y++) {
            var cell = row[y];
            if (isNaN(cell)) break compute_sum;
            sum += cell;
        }
    }
    success = true;
}
// Здесь инструкция break выполняет переход. Если будет выполнено условие
// success == false, значит, что-то не так в полученной матрице.
// В противном случае переменная sum будет содержать сумму всех элементов матрицы

for(i = 0; i < data.length; i++) {
    if (!data[i]) continue; // Не обрабатывать неопределенные данные
    total += data[i];
}

// throw - возбуждение исключения
// try/catch/finally - обработка исключений
function factorial(x) {
    // Если входной аргумент не является допустимым значением, возбуждается исключение!
    if (x < 0) throw new Error("x не может быть отрицательным");
    // В противном случае значение вычисляется и возвращается нормальным образом
    for(var f = 1; x > 1; f *= x, x--) /* пустое тело цикла */ ;
    return f;
}

try {
    // Обычно этот код без сбоев работает от начала до конца.
    // Но в какой-то момент в нем может быть сгенерировано исключение
    // либо непосредственно с помощью инструкции throw, либо косвенно -
    // вызовом метода, генерирующего исключение.
}
catch (e) {
    // Инструкции в этом блоке выполняются тогда и только тогда, когда в блоке try
    // возникает исключение. Эти инструкции могут использовать локальную переменную e,
    // ссылающуюся на объект Error или на другое значение, указанное в инструкции throw.
    // Этот блок может либо некоторым образом обработать исключение, либо
    // проигнорировать его, делая что-то другое, либо заново сгенерировать
    // исключение с помощью инструкции throw.
}
finally {
    // Этот блок содержит инструкции, которые выполняются всегда, независимо от того,
    // что произошло в блоке try. Они выполняются, если блок try завершился:
    // 1) как обычно, достигнув конца блока 
    // 2) из-за инструкции break, continue или return
    // 3) с исключением, обработанным приведенным в блоке catch выше
    // 4) с неперехваченным исключением, которое продолжает свое
    // распространение на более высокие уровни
}

try {
    // Запросить число у пользователя
    var n = Number(prompt("Введите положительное число", ""));
    // Вычислить факториал числа, предполагая, что входные данные корректны
    var f = factorial(n);
    // Вывести результат
    alert(n + "! = " + f);
}
catch (ex) { // Если данные некорректны, управление будет передано сюда
    alert(ex); // Сообщить пользователю об ошибке
}

